{"name":"Asteroid","tagline":"An alternative client for a Meteor backend","body":"#asteroid\r\n\r\nAn alternative browser client for a Meteor backend.\r\n\r\n##Why\r\n\r\nI consider Meteor to be an awesome platform, but I find its templating system\r\nnot sufficient for building truly amazing web apps. While it is possible\r\nto use it alongside front-end frameworks like AngularJS, the integration is\r\nnot painless, and the developer needs to jump through hoops to get what he wants.\r\n\r\nBy conneting to any Meteor backend via the Distributed Data Protocol, Asteroid\r\nallows the developer to take advantage of the greatest features of Meteor's back-end\r\nplatform without having to compromise on the front-end.\r\n\r\n##Install\r\n\r\nFirst, dowload the library:\r\n\r\n    bower install asteroid\r\n\r\nThen, add the necessary libraries to your index.html:\r\n\r\n    <script src=\"bower_components/ddp.js/dpp.js\"></script>\r\n    <script src=\"bower_components/q/q.js\"></script>\r\n    <script src=\"bower_components/asteroid/dist/asteroid.js\"></script>\r\n\r\n##Advantages over the canonical Meteor front-end\r\n\r\n* Small footprint. The library is about ~10Kb minified. It depends on ddp.js (~4Kb minified), and a q-compatible promise library (q is ~17Kb minified, for a lightweight alternative, check out my fork of [ayepromise](https://github.com/mondora/ayepromise), which is ~2Kb minified).\r\n\r\n* Framework agnostic. Use the tools you already know and love to build your app.\r\n\r\n* Allows to use Meteor as a full-blown backend or just as a real-time platform pluggable into any existing project.\r\n\r\n* Easily connect to multiple Meteor servers at the same time, perfect for building admin interfaces.\r\n\r\n##Test\r\n\r\n    npm test\r\n\r\n##Example\r\n\r\n<span style=\"color:red;\">Warning: the API is in still a bit in flux.</span>\r\n\r\n```javascript\r\n// Connect to a Meteor backend\r\nvar ceres = new Asteroid(\"localhost:3000\");\r\n\r\n// Use real-time collections\r\nceres.subscribe(\"tasks\");\r\nvar tasks = ceres.createCollection(\"tasks\");\r\ntasks.insert({\r\n  description: \"Do the laundry\"\r\n});\r\nvar laundryTaskQuery = tasks.reactiveQuery({description: \"Do the laundry\"});\r\nconsole.log(laundryTaskQuery.result); // Logs the array of results\r\n\r\n// Login your user\r\nceres.loginWithTwitter();\r\n```\r\n\r\n##Demo\r\n\r\n[Example todo app using AngularJS](https://mondora.github.io/meteor-todo)\r\n\r\n[Same app using Meteor's front-end client](https://mondora.meteor.com)\r\n\r\nThe [Asteroid client](http://s27.postimg.org/hc1qjnjsz/Asteroid.png), which includes AngularJS (not required, but included for the demo), is almost half the size of the [Meteor client](http://s29.postimg.org/3mxaifziv/Meteor.png).\r\n\r\n\r\n\r\n##API\r\n\r\n\r\n\r\n##Asteroid methods\r\n\r\n\r\n\r\n###new Asteroid(host, ssl, debug)\r\n\r\nCreates a new Asteroid instance, that is, a connection to a\r\nMeteor server (via DDP).\r\n\r\nAfter being constructed, the instance will connect itself\r\nto the Meteor backend. It will also try, upon connection,\r\nto resume a previous login session (with a token saved in\r\nlocalstorage). The `Asteroid.resumeLoginPromise` property\r\nstores a promise which will be resolved if the resume was\r\nsuccessful, rejected otherwise.\r\n\r\nIf `SockJS` is defined, it will be used as the socket\r\ntransport. Otherwise `WebSocket` will be used. Note that\r\n`SockJS` is required for IE9 support.\r\n\r\n#####Arguments\r\n\r\n* `host` **string** _required_: the address of the Meteor\r\n  server, e.g. `example.meteor.com`\r\n\r\n* `ssl` **boolean** _optional_: whether to use SSL. Defaults\r\n  to `false`.\r\n\r\n* `debug`**boolean** _optional_: if set to `true`, DDP messages\r\n  will be logged in the console. Defaults to `false`.\r\n\r\n#####Returns\r\n\r\nAn Asteroid instance.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.on(event, handler)\r\n\r\nRegisters an event handler for the specified event.\r\n\r\n#####Arguments\r\n\r\n* `event` **string** _required_: the name of the event.\r\n\r\n* `handler` **function** _required_: the handler.\r\n\r\nAn Asteroid instance emits the following events:\r\n\r\n* `connected`: emitted when the DDP connection is\r\n  established. No arguments are passed to the handler.\r\n\r\n* `login`: emitted when the user logs in. The id of the\r\n  logged in user will be passed as argument to the handler.\r\n\r\n* `logout`: emitted when the user logs out. No arguments are\r\n  passed to the handler.\r\n\r\n#####Returns\r\n\r\nNothing\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.loginWith ... ()\r\n\r\nLogs the user in via the specified third party (oauth)\r\nservice.\r\n\r\n#####Available services\r\n\r\n* **facebook**: `loginWithFacebook`\r\n\r\n* **google**: `loginWithGoogle`\r\n\r\n* **twitter**: `loginWithTwitter`\r\n\r\n* **github**: `loginWithGithub`\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with the logged user id if\r\nthe login is successful. Otherwise it'll be rejected with\r\nthe error.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.login(username, password)\r\n\r\n<span style=\"color:red;\">Not yet implemented</span>\r\n\r\nLogs the user in using the SRP protocol.\r\n\r\n#####Arguments\r\n\r\n* `username` **string** _required_: the username\r\n\r\n* `password` **string** _required_: the password. Note: since\r\n  Meteor uses the SRP protocol, the password is never\r\n  actually sent to the server.\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with the logged user id if\r\nthe login is successful. Otherwise it'll be rejected with\r\nthe error.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.logout()\r\n\r\nLogs out the user.\r\n\r\n#####Arguments\r\n\r\nNone\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with if the logout is\r\nsuccessful. Otherwise it'll be rejected with the error.\r\n\r\n------------------------------------------------------------\r\n###Asteroid.subscribe(name, [param1, param2, ...])\r\n\r\nSubscribes to the specified subscription. If a subscription\r\nby that name is already present (and successful), first\r\nAsteroid unsubscribes from it.\r\n\r\n#####Arguments\r\n\r\n* `name` **string** _required_: the name of the subscription.\r\n\r\n* `param1, param2, ...` _optional_: a list of parameters\r\n  that will be passed to the publish function on the server.\r\n\r\n#####Returns\r\n\r\nA promise, this will be resolved with the `id` of the\r\nsubscription if the subscription is successful. It will be\r\nrejected otherwise.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.unsubscribe(id)\r\n\r\nUnsubscribes from the specified subscription.\r\n\r\n#####Arguments\r\n\r\n* `id` **string** _required_: the `id` of the subscription, as\r\n  returned by the `subscribe` method\r\n\r\n#####Returns\r\n\r\nNothing\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.call(method, [param1, param2, ...])\r\n\r\nCalls a server-side method with the specified arguments.\r\n\r\n#####Arguments\r\n\r\n* `method` **string** _required_: the name of the method to\r\n  call.\r\n\r\n* `param1, param2, ...` _optional_: a list of parameters\r\n  that will be passed to the method on the server.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `result` and `updated`. Both\r\nproperties are promises.\r\n\r\nIf the method is successful, the `result` promise will be\r\nresolved with the return value passed by the server. The\r\n`updated` promise will be resolved with nothing once the\r\nserver emits the `updated` message, that tells the client\r\nthat any side-effect that the method execution caused on the\r\ndatabase has been reflected on the client (for example, if\r\nthe method caused the insertion of an item into a\r\ncollection, the client has been notified of said insertion).\r\n\r\nIf the method fails, the `result` promise will be rejected\r\nwith the error returned by the server. The `updated`\r\npromise will be rejected as well (with nothing).\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.apply(method, params)\r\n\r\nSame as Asteroid.call, but using as array of parameters\r\ninstead of a list.\r\n\r\n#####Arguments\r\n\r\n* `method` **string** _required_: the name of the method to\r\n  call.\r\n\r\n* `params` **array** _optional_: an array of parameters that\r\n  will be passed to the method on the server.\r\n\r\n#####Returns\r\n\r\nSame as Asteroid.call, see above.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.createCollection(name)\r\n\r\nCreates and returns a collection. If the collection already\r\nexists, nothing changes and the existing one is returned.\r\n\r\n#####Arguments\r\n\r\n* `name` **string** _required_: the name of the collection to\r\n  create.\r\n\r\n#####Returns\r\n\r\nA reference to the collection.\r\n\r\n#####Note\r\n\r\nAsteroid auto-creates collections for you. For example, if\r\nyou subscribe to an hypothetical `posts` subscription, the\r\nserver will start sending the client `added` messages that\r\nrefer to items of the `posts` collection. With Meteor's\r\nfront-end we would normally need to define the\r\n`posts`collection before we can access it.\r\n\r\nWith Asteroid, when the first `added` message is received,\r\nif the `posts` collection doesn't exist yet, it will get\r\nautomatically created. We can then get a reference to that\r\ncollection by calling `createCollection` (or by accessing\r\nthe semi-private Asteroid.collections dictionary).\r\n\r\n\r\n\r\n##Asteroid.Collection methods\r\n\r\nAll the following methods use latency compensation.\r\n\r\n\r\n\r\n###Collection.insert(item)\r\n\r\nInserts an item into a collection. If the item does not\r\nhave an _id property, one will be automatically generated\r\nfor it.\r\n\r\n#####Arguments\r\n\r\n* `item` **object** _required_: the object to insert. Must\r\n  be JSON serializable. Optional support for EJSON is\r\n  planned.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `local` and `remote`. Both\r\nproperties are promises.\r\n\r\nThe local promise is immediately resolved with the _id of\r\nthe inserted item. That is, unless an error occurred. In\r\nthat case, an exception will be raised. (TODO: this is a bit\r\nof an API inconsistency which should be fixed).\r\n\r\nThe remote promise is resolved with the _id of the inserted\r\nitem if the remote insert is successful. Otherwise it's\r\nrejected with the reason of the failure.\r\n\r\n------------------------------------------------------------\r\n\r\n###Collection.update(id, item)\r\n\r\nUpdates the specified item.\r\n\r\n#####Arguments\r\n\r\n* `id` **string** _required_: the id of the item to update.\r\n\r\n* `item` **object** _required_: the object that will\r\n  replace the old one.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `local` and `remote`. Both\r\nproperties are promises.\r\n\r\nThe local promise is immediately resolved with the _id of\r\nthe updated item. That is, unless an error occurred. In\r\nthat case, an exception will be raised. (TODO: this is a bit\r\nof an API inconsistency which should be fixed).\r\n\r\nThe remote promise is resolved with the _id of the updated\r\nitem if the remote update is successful. Otherwise it's\r\nrejected with the reason of the failure.\r\n\r\n#####Note\r\n\r\n<span style=\"color:red;\">The API greatly differs from\r\nMeteor's API. Aligning the two is on the TODO list.</span>\r\n\r\n------------------------------------------------------------\r\n\r\n###Collection.remove(id)\r\n\r\nRemoves the specified item.\r\n\r\n#####Arguments\r\n\r\n* `id` **string** _required_: the id of the item to remove.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `local` and `remote`. Both\r\nproperties are promises.\r\n\r\nThe local promise is immediately resolved with the _id of\r\nthe removed item. That is, unless an error occurred. In\r\nthat case, an exception will be raised. (TODO: this is a bit\r\nof an API inconsistency which should be fixed).\r\n\r\nThe remote promise is resolved with the _id of the removed\r\nitem if the remote remove is successful. Otherwise it's\r\nrejected with the reason of the failure.\r\n\r\n------------------------------------------------------------\r\n\r\n###Collection.reactiveQuery(selector)\r\n\r\nGets a \"reactive\" subset of the collection.\r\n\r\n#####Arguments\r\n\r\n* `selector` **object or function** _required_: a\r\n  MongoDB-style selector. Actually for now only a simple\r\n  selector is supported (example `{key1: val1, key2.subkey1:\r\n  val2}`). To compensate for this, you can also pass in a\r\n  filter function which will be invoked on each item of the\r\n  collection. If the function returns a truthy value, the\r\n  item will be included, otherwise it will be left out.\r\n  Help on adding support for more complex selectors is\r\n  appreciated.\r\n\r\n#####Returns\r\n\r\nA ReactiveQuery instance.\r\n\r\n\r\n\r\n##ReactiveQuery methods and properties\r\n\r\n\r\n\r\n###ReactiveQuery.result\r\n\r\nThe array of items in the collection that matched the query.\r\n\r\n------------------------------------------------------------\r\n\r\n###ReactiveQuery.on(event, handler)\r\n\r\nRegisters a handler for an event.\r\n\r\n#####Arguments\r\n\r\n* `event` **string** _required_: the name of the event.\r\n\r\n* `handler` **function** _required_: the handler for the\r\n  event.\r\n\r\nPossible events are:\r\n\r\n* `change`: emitted whenever the result of the query\r\n  changes. The id of the item that changed is passed to the\r\n  handler.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}