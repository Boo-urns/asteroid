{"name":"Asteroid","tagline":"An alternative client for a Meteor backend","body":"[![Build Status](https://travis-ci.org/mondora/asteroid.svg?branch=master)](https://travis-ci.org/mondora/asteroid)\r\n[![Coverage Status](https://coveralls.io/repos/mondora/asteroid/badge.png)](https://coveralls.io/r/mondora/asteroid)\r\n[![Code Climate](https://codeclimate.com/github/mondora/asteroid.png)](https://codeclimate.com/github/mondora/asteroid)\r\n\r\n[Example todo app using AngularJS.](https://mondora.github.io/meteor-todo)\r\n[Same app using Meteor's front-end.](https://meteor.todo.pscanf.com)\r\n\r\n#asteroid\r\n\r\nA javascript client (browser and node) for a Meteor backend.\r\n\r\n##Table of contents\r\n\r\n[Why](#why)\r\n\r\n[Install](#install)\r\n\r\n[Example usage](#example-usage)\r\n\r\n[Advantages over the canonical Meteor front-end](#advantages-over-the-canonical-meteor-front-end)\r\n\r\n[Build asteroid locally](#build-asteroid-locally)\r\n\r\n[Contribute](#contribute)\r\n\r\n[Todo](#todo)\r\n\r\n[API](#api)\r\n\r\n##Why\r\n\r\nMeteor is an awesome platform, but its canonical\r\nfront-end is not very flexible. Asteroid gives the\r\npossibility to connect to a Meteor backend with any JS app.\r\n\r\nSome of the things Asteroid allows you to do are:\r\n\r\n*\tmake any existing application reactive\r\n\r\n*\tuse any front-end framework you want with Meteor\r\n\r\n*\tdevelop browser extensions backed by Meteor\r\n\r\n[Blog post on the library](http://mondora.com/asteroid-a-better-way-to-build-meteor-apps/)\r\n\r\n##Install\r\n\r\n###In the browser\r\n\r\nFirst, dowload the library:\r\n\r\n    bower install asteroid\r\n\r\nThen, add the necessary libraries to your index.html:\r\n\r\n    <script src=\"bower_components/ddp.js/src/dpp.js\"></script>\r\n    <script src=\"bower_components/q/q.js\"></script>\r\n    <script src=\"bower_components/asteroid/dist/asteroid.js\"></script>\r\n\r\n###In node\r\n\r\nDownload the package:\r\n\r\n    npm install git+https://github.com/mondora/asteroid\r\n\r\nRequire it in your project:\r\n\r\n    var Asteroid = require(\"asteroid\");\r\n\r\n##Example usage\r\n\r\n**Warning: the API is in still a bit in flux.**\r\n\r\n```javascript\r\n// Connect to a Meteor backend\r\nvar ceres = new Asteroid(\"localhost:3000\");\r\n\r\n// Use real-time collections\r\nceres.subscribe(\"tasks\");\r\nvar tasks = ceres.getCollection(\"tasks\");\r\ntasks.insert({\r\n  description: \"Do the laundry\"\r\n});\r\nvar laundryTaskQuery = tasks.reactiveQuery({description: \"Do the laundry\"});\r\nconsole.log(laundryTaskQuery.result); // Logs the array of results\r\n\r\n// Login your user\r\nceres.loginWithTwitter();\r\n```\r\n\r\n##Advantages over the canonical Meteor front-end\r\n\r\n* Small footprint. The library is about ~10Kb minified. It\r\n  depends on ddp.js (~4Kb minified), and a q-compatible\r\n  promise library (q is ~17Kb minified, for a lightweight\r\n  alternative, check out my fork of\r\n  [ayepromise](https://github.com/mondora/ayepromise), which\r\n  is ~2Kb minified). In the demo app, the [Asteroid\r\n  client](http://s27.postimg.org/hc1qjnjsz/Asteroid.png),\r\n  which includes AngularJS (not required, but included for\r\n  the demo), is almost half the size of the [Meteor\r\n  client](http://s29.postimg.org/3mxaifziv/Meteor.png).\r\n\r\n* Framework agnostic. Use the tools you already know and\r\n  love to build your app.\r\n\r\n* Allows to use Meteor as a full-blown backend or just as a\r\n  real-time platform pluggable into any existing project.\r\n\r\n* Easily connect to multiple Meteor servers at the same\r\n  time, perfect for building admin interfaces.\r\n\r\n \r\n##Build asteroid locally\r\n\r\nClone the repository (or your fork) on your computer.\r\n\r\n    git clone https://github.com/mondora/asteroid\r\n\r\nEnter the project's directory and install the required\r\ndependencies:\r\n\r\n    cd asteroid/\r\n    npm install\r\n    bower install\r\n\r\nFor conveninece, I suggest installing a few `npm` modules\r\nglobally:\r\n\r\n    npm install -g gulp karma mocha\r\n\r\nModfy the source files under `src/` as needed, then rebuild\r\nthe distribution files, which will get placed in the `dist/`\r\ndirectory:\r\n\r\n    gulp buildBrowser\r\n    gulp buildNode\r\n\r\nYou can add your unit tests in one of the files under `test/unit/`\r\n(or you can add another file in that folder if needed).\r\nOnce you've added unit tests, you need also to rebuild the\r\ntests:\r\n\r\n    gulp buildTests\r\n\r\nNow you can run tests. For **nodejs** run:\r\n\r\n    mocha test/asteroid.unit.js\r\n\r\nFor the browser run:\r\n\r\n    karma start test/karma.conf.js\r\n\r\nYou can set up an automated dev environment with automatic\r\nre-builds of source files and tests by running:\r\n\r\n    gulp dev\r\n    \r\nThis will set up a webserver listening on `localhost:8080`, where\r\nyou'll find a report for browser unit tests being run.\r\n\r\n##Contribute\r\n\r\nContributions are as always very very welcome. If you\r\nwant to help but don't know how to get started,\r\n[feel free to schedule a pair programming session with me!](http://mondora.com/#!/post/4ddde81d13b2152ab068b54e85bd4a2a)\r\n\r\n*Contributing guidelines coming soon.*\r\n\r\n##Todo\r\n\r\nHere follows a list of things which need to be done before\r\nthe library can be considered \"production ready\":\r\n\r\n* allow using selectors and modifiers to update an item\r\n  (currently you can only replace top-level fields in the\r\n  document with the Collection.update method). Difficulty\r\n  8/10\r\n\r\n* allow using selectors with the reactiveQuery method.\r\n  Difficulty 8/10\r\n\r\n* add EJSON support (by porting Meteor's EJSON package).\r\n  Difficulty 3/10\r\n\r\n* just an idea, but I'd fancy trying to integrate it with\r\n  [nedb](https://github.com/louischatriot/nedb)\r\n\r\n\r\n\r\n\r\n\r\n##API\r\n\r\n\r\n\r\n##Asteroid methods\r\n\r\n\r\n\r\n###new Asteroid(host, ssl, interceptor)\r\n\r\nCreates a new Asteroid instance, that is, a connection to a\r\nMeteor server (via DDP).\r\n\r\nAfter being constructed, the instance will connect itself to\r\nthe Meteor backend. It will also try, upon connection, to\r\nresume a previous login session (with a token saved in\r\nlocalstorage). The `Asteroid.resumeLoginPromise` property\r\nstores a promise which will be resolved if the resume was\r\nsuccessful, rejected otherwise.\r\n\r\nIf `SockJS` is defined, it will be used as the socket\r\ntransport. Otherwise `WebSocket` will be used. Note that\r\n`SockJS` is required for IE9 support.\r\n\r\n#####Arguments\r\n\r\n* `host` **string** _required_: the address of the Meteor\r\n  server, e.g. `example.meteor.com`\r\n\r\n* `ssl` **boolean** _optional_: whether to use SSL. Defaults\r\n  to `false`.\r\n\r\n* `interceptor` **function** _optional_: a function which\r\n  will intercept any socket event. It will be called with an\r\n  event object containing the name of the event, the\r\n  timestamp of the event, and details about the event (for\r\n  instance, in case of a \"socket_message_received\" event,\r\n  it'll contain the peyload of the message).\r\n\r\n#####Returns\r\n\r\nAn Asteroid instance.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.on(event, handler)\r\n\r\nRegisters an event handler for the specified event.\r\n\r\n#####Arguments\r\n\r\n* `event` **string** _required_: the name of the event.\r\n\r\n* `handler` **function** _required_: the handler.\r\n\r\nAn Asteroid instance emits the following events:\r\n\r\n* `connected`: emitted when the DDP connection is\r\n  established. No arguments are passed to the handler.\r\n\r\n* `login`: emitted when the user logs in. The id of the\r\n  logged in user will be passed as argument to the handler.\r\n\r\n* `logout`: emitted when the user logs out. No arguments are\r\n  passed to the handler.\r\n\r\n#####Returns\r\n\r\nNothing\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.loginWith ... ()\r\n\r\nLogs the user in via the specified third party (oauth)\r\nservice.\r\n\r\n#####Available services\r\n\r\n* **facebook**: `loginWithFacebook`\r\n\r\n* **google**: `loginWithGoogle`\r\n\r\n* **twitter**: `loginWithTwitter`\r\n\r\n* **github**: `loginWithGithub`\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with the logged user id if\r\nthe login is successful. Otherwise it'll be rejected with\r\nthe error.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.createUser(usernameOrEmail, password, profile)\r\n\r\nCreates a user and logs him in. **Does not** hash the\r\npassword before sending it to the server. This is not a\r\nproblem, since you'll probably be using SSL anyway.\r\n\r\n#####Arguments\r\n\r\n* `usernameOrEmail` **string** _required_: the username or\r\n  email.\r\n\r\n* `password` **string** _required_: the password.\r\n\r\n* `profile` **object** _optional_: a blackbox, you can throw\r\n  anything in here and it'll end up into `user.profile`.\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with the logged user id if\r\nthe creation and login are successful. Otherwise it'll be\r\nrejected with an error.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.loginWithPassword(usernameOrEmail, password)\r\n\r\nLogs the user in username/email and password. **Does not**\r\nhash the password before sending it to the server. This is\r\nnot a problem, since you'll probably be using SSL anyway.\r\n\r\n#####Arguments\r\n\r\n* `usernameOrEmail` **string** _required_: the username or\r\n  email.\r\n\r\n* `password` **string** _required_: the password.\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with the logged user id if\r\nthe login is successful. Otherwise it'll be rejected with\r\nan error.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.logout()\r\n\r\nLogs out the user.\r\n\r\n#####Arguments\r\n\r\nNone\r\n\r\n#####Returns\r\n\r\nA promise which will be resolved with if the logout is\r\nsuccessful. Otherwise it'll be rejected with the error.\r\n\r\n------------------------------------------------------------\r\n###Asteroid.subscribe(name, [param1, param2, ...])\r\n\r\nSubscribes to the specified subscription. If an identical\r\nsubscription (same name and parameters) has already been\r\nmade, Asteroid will return that subscription.\r\n\r\n#####Arguments\r\n\r\n* `name` **string** _required_: the name of the subscription.\r\n\r\n* `param1, param2, ...` _optional_: a list of parameters\r\n  that will be passed to the publish function on the server.\r\n\r\n#####Returns\r\n\r\nA subscription instance.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.Subscription\r\n\r\nSubscription instances have the following properties:\r\n\r\n* `id` **string**: the `id` of the subscription, as\r\n  returned by the `ddp.sub` method\r\n\r\n* `ready` **promise**: a promise which will be resolved with\r\n  the `id` of the subscription if the subscription succeeds\r\n  (we receive the ddp `ready` message), or will be rejected\r\n  if it fails (we receive, upon subscribing, the `nosub`\r\n  message).\r\n\r\nAnd the following method:\r\n\r\n* `stop`: it takes no argument, sends the ddp `unsub`\r\n  message and deletes the subscription so it can be garbage\r\n  collected.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.call(method, [param1, param2, ...])\r\n\r\nCalls a server-side method with the specified arguments.\r\n\r\n#####Arguments\r\n\r\n* `method` **string** _required_: the name of the method to\r\n  call.\r\n\r\n* `param1, param2, ...` _optional_: a list of parameters\r\n  that will be passed to the method on the server.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `result` and `updated`. Both\r\nproperties are promises.\r\n\r\nIf the method is successful, the `result` promise will be\r\nresolved with the return value passed by the server. The\r\n`updated` promise will be resolved with nothing once the\r\nserver emits the `updated` message, that tells the client\r\nthat any side-effect that the method execution caused on the\r\ndatabase has been reflected on the client (for example, if\r\nthe method caused the insertion of an item into a\r\ncollection, the client has been notified of said insertion).\r\n\r\nIf the method fails, the `result` promise will be rejected\r\nwith the error returned by the server. The `updated`\r\npromise will be rejected as well (with nothing).\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.apply(method, params)\r\n\r\nSame as Asteroid.call, but using as array of parameters\r\ninstead of a list.\r\n\r\n#####Arguments\r\n\r\n* `method` **string** _required_: the name of the method to\r\n  call.\r\n\r\n* `params` **array** _optional_: an array of parameters that\r\n  will be passed to the method on the server.\r\n\r\n#####Returns\r\n\r\nSame as Asteroid.call, see above.\r\n\r\n------------------------------------------------------------\r\n\r\n###Asteroid.getCollection(name)\r\n\r\nCreates and returns a collection. If the collection already\r\nexists, nothing changes and the existing one is returned.\r\n\r\n#####Arguments\r\n\r\n* `name` **string** _required_: the name of the collection to\r\n  create.\r\n\r\n#####Returns\r\n\r\nA reference to the collection.\r\n\r\n#####Note\r\n\r\nAsteroid auto-creates collections for you. For example, if\r\nyou subscribe to an hypothetical `posts` subscription, the\r\nserver will start sending the client `added` messages that\r\nrefer to items of the `posts` collection. With Meteor's\r\nfront-end we would normally need to define the\r\n`posts`collection before we can access it.\r\n\r\nWith Asteroid, when the first `added` message is received,\r\nif the `posts` collection doesn't exist yet, it will get\r\nautomatically created. We can then get a reference to\r\nthat collection by calling `createCollection` (or by\r\naccessing the semi-private Asteroid.collections\r\ndictionary).\r\n\r\n\r\n\r\n##Asteroid.Collection methods\r\n\r\nAll the following methods use latency compensation.\r\n\r\n\r\n\r\n###Collection.insert(item)\r\n\r\nInserts an item into a collection. If the item does not\r\nhave an `_id` property, one will be automatically generated\r\nfor it.\r\n\r\n#####Arguments\r\n\r\n* `item` **object** _required_: the object to insert. Must\r\n  be JSON serializable. Optional support for EJSON is\r\n  planned.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `local` and `remote`. Both\r\nproperties are promises.\r\n\r\nThe local promise is immediately resolved with the `_id` of\r\nthe inserted item. That is, unless an error occurred. In\r\nthat case, an exception will be raised. (TODO: this is a bit\r\nof an API inconsistency which maybe should be fixed).\r\n\r\nThe remote promise is resolved with the `_id` of the\r\ninserted item if the remote insert is successful. Otherwise\r\nit's rejected with the reason of the failure.\r\n\r\n------------------------------------------------------------\r\n\r\n###Collection.update(id, item)\r\n\r\nUpdates the specified item.\r\n\r\n#####Arguments\r\n\r\n* `id` **string** _required_: the id of the item to update.\r\n\r\n* `item` **object** _required_: the object that will\r\n  replace the old one.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `local` and `remote`. Both\r\nproperties are promises.\r\n\r\nThe local promise is immediately resolved with the `_id` of\r\nthe updated item. That is, unless an error occurred. In\r\nthat case, an exception will be raised. (TODO: this is a bit\r\nof an API inconsistency which should be fixed).\r\n\r\nThe remote promise is resolved with the `_id` of the updated\r\nitem if the remote update is successful. Otherwise it's\r\nrejected with the reason of the failure.\r\n\r\n#####Note\r\n\r\n<span style=\"color:red;\">The API greatly differs from\r\nMeteor's API. Aligning the two is on the TODO list.</span>\r\n\r\n------------------------------------------------------------\r\n\r\n###Collection.remove(id)\r\n\r\nRemoves the specified item.\r\n\r\n#####Arguments\r\n\r\n* `id` **string** _required_: the id of the item to remove.\r\n\r\n#####Returns\r\n\r\nAn object with two properties: `local` and `remote`. Both\r\nproperties are promises.\r\n\r\nThe local promise is immediately resolved with the `_id` of\r\nthe removed item. That is, unless an error occurred. In\r\nthat case, an exception will be raised. (TODO: this is a bit\r\nof an API inconsistency which should be fixed).\r\n\r\nThe remote promise is resolved with the `_id` of the removed\r\nitem if the remote remove is successful. Otherwise it's\r\nrejected with the reason of the failure.\r\n\r\n------------------------------------------------------------\r\n\r\n###Collection.reactiveQuery(selector)\r\n\r\nGets a \"reactive\" subset of the collection.\r\n\r\n#####Arguments\r\n\r\n* `selector` **object or function** _required_: a\r\n  MongoDB-style selector. Actually for now only a simple\r\n  selector is supported (example `{key1: val1, key2.subkey1:\r\n  val2}`). To compensate for this, you can also pass in a\r\n  filter function which will be invoked on each item of the\r\n  collection. If the function returns a truthy value, the\r\n  item will be included, otherwise it will be left out.\r\n  Help on adding support for more complex selectors is\r\n  appreciated.\r\n\r\n#####Returns\r\n\r\nA ReactiveQuery instance.\r\n\r\n\r\n\r\n##ReactiveQuery methods and properties\r\n\r\n\r\n\r\n###ReactiveQuery.result\r\n\r\nThe array of items in the collection that matched the query.\r\n\r\n------------------------------------------------------------\r\n\r\n###ReactiveQuery.on(event, handler)\r\n\r\nRegisters a handler for an event.\r\n\r\n#####Arguments\r\n\r\n* `event` **string** _required_: the name of the event.\r\n\r\n* `handler` **function** _required_: the handler for the\r\n  event.\r\n\r\nPossible events are:\r\n\r\n* `change`: emitted whenever the result of the query\r\n  changes. The id of the item that changed is passed to the\r\n  handler.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}